From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: deepak1556 <hop2deep@gmail.com>
Date: Thu, 13 Oct 2022 20:30:12 +0900
Subject: Preconnect manager

* Patch disables the profile related changes added in
https://chromium-review.googlesource.com/c/chromium/src/+/3928470.
* Also avoids including chrome/browser/predictors/resource_prefetch_predictor.h
in favor of defining PreconnectRequest in this file since we don't build
the header.

diff --git a/chrome/browser/predictors/preconnect_manager.cc b/chrome/browser/predictors/preconnect_manager.cc
index 02bdfd1f176d4ce44984387226b6fc2e6551f15e..073c505c31d5daa08d3582a4739ef8703552fd6e 100644
--- a/chrome/browser/predictors/preconnect_manager.cc
+++ b/chrome/browser/predictors/preconnect_manager.cc
@@ -13,9 +13,11 @@
 #include "base/not_fatal_until.h"
 #include "base/trace_event/trace_event.h"
 #include "chrome/browser/predictors/predictors_features.h"
+#if 0
 #include "chrome/browser/predictors/resource_prefetch_predictor.h"
 #include "chrome/browser/preloading/preloading_prefs.h"
 #include "chrome/browser/profiles/profile.h"
+#endif
 #include "content/public/browser/browser_context.h"
 #include "content/public/browser/browser_task_traits.h"
 #include "content/public/browser/browser_thread.h"
@@ -26,6 +28,20 @@ namespace predictors {
 
 const bool kAllowCredentialsOnPreconnectByDefault = true;
 
+// NOTE(nornagon): this is copied from
+// //chrome/browser/predictors/resource_prefetch_predictor.cc we don't need
+// anything in that file other than this constructor.
+PreconnectRequest::PreconnectRequest(
+    const url::Origin& origin,
+    int num_sockets,
+    const net::NetworkAnonymizationKey& network_anonymization_key)
+    : origin(origin),
+      num_sockets(num_sockets),
+      network_anonymization_key(network_anonymization_key) {
+  DCHECK_GE(num_sockets, 0);
+  DCHECK(!network_anonymization_key.IsEmpty());
+}
+
 PreconnectedRequestStats::PreconnectedRequestStats(const url::Origin& origin,
                                                    bool was_preconnected)
     : origin(origin), was_preconnected(was_preconnected) {}
@@ -86,19 +102,23 @@ PreconnectManager::PreconnectManager(base::WeakPtr<Delegate> delegate,
 PreconnectManager::~PreconnectManager() = default;
 
 bool PreconnectManager::IsEnabled() {
+#if 0
   Profile* profile = Profile::FromBrowserContext(browser_context_);
   if (!profile) {
     return false;
   }
   return prefetch::IsSomePreloadingEnabled(*profile->GetPrefs()) ==
          content::PreloadingEligibility::kEligible;
+#endif
+  return true;
 }
 
 void PreconnectManager::Start(const GURL& url,
                               std::vector<PreconnectRequest> requests) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  if (!IsEnabled())
+  if (!IsEnabled()) {
     return;
+  }
   if (!url.SchemeIsHTTPOrHTTPS()) {
     return;
   }
@@ -125,10 +145,12 @@ void PreconnectManager::StartPreresolveHost(
     const GURL& url,
     const net::NetworkAnonymizationKey& network_anonymization_key) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  if (!IsEnabled())
+  if (!IsEnabled()) {
     return;
-  if (!url.SchemeIsHTTPOrHTTPS())
+  }
+  if (!url.SchemeIsHTTPOrHTTPS()) {
     return;
+  }
   PreresolveJobId job_id = preresolve_jobs_.Add(std::make_unique<PreresolveJob>(
       url.DeprecatedGetOriginAsURL(), 0, kAllowCredentialsOnPreconnectByDefault,
       network_anonymization_key, nullptr));
@@ -141,8 +163,9 @@ void PreconnectManager::StartPreresolveHosts(
     const std::vector<GURL>& urls,
     const net::NetworkAnonymizationKey& network_anonymization_key) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  if (!IsEnabled())
+  if (!IsEnabled()) {
     return;
+  }
   // Push jobs in front of the queue due to higher priority.
   for (const GURL& url : base::Reversed(urls)) {
     if (!url.SchemeIsHTTPOrHTTPS()) {
@@ -163,10 +186,12 @@ void PreconnectManager::StartPreconnectUrl(
     bool allow_credentials,
     net::NetworkAnonymizationKey network_anonymization_key) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  if (!IsEnabled())
+  if (!IsEnabled()) {
     return;
-  if (!url.SchemeIsHTTPOrHTTPS())
+  }
+  if (!url.SchemeIsHTTPOrHTTPS()) {
     return;
+  }
   PreresolveJobId job_id = preresolve_jobs_.Add(std::make_unique<PreresolveJob>(
       url.DeprecatedGetOriginAsURL(), 1, allow_credentials,
       std::move(network_anonymization_key), nullptr));
@@ -192,8 +217,9 @@ void PreconnectManager::PreconnectUrl(
     const net::NetworkAnonymizationKey& network_anonymization_key) const {
   DCHECK(url.DeprecatedGetOriginAsURL() == url);
   DCHECK(url.SchemeIsHTTPOrHTTPS());
-  if (observer_)
+  if (observer_) {
     observer_->OnPreconnectUrl(url, num_sockets, allow_credentials);
+  }
 
   auto* network_context = GetNetworkContext();
 
@@ -270,8 +296,9 @@ void PreconnectManager::TryToLaunchPreresolveJobs() {
                          weak_factory_.GetWeakPtr(), job_id));
       if (info) {
         ++info->inflight_count;
-        if (delegate_)
+        if (delegate_) {
           delegate_->PreconnectInitiated(info->url, job->url);
+        }
       }
       ++inflight_preresolves_count_;
     } else {
@@ -294,9 +321,10 @@ void PreconnectManager::OnPreresolveFinished(PreresolveJobId job_id,
   PreresolveJob* job = preresolve_jobs_.Lookup(job_id);
   DCHECK(job);
 
-  if (observer_)
+  if (observer_) {
     observer_->OnPreresolveFinished(job->url, job->network_anonymization_key,
                                     success);
+  }
 
   job->resolve_host_client = nullptr;
   FinishPreresolveJob(job_id, success);
@@ -347,8 +375,9 @@ void PreconnectManager::FinishPreresolveJob(PreresolveJobId job_id,
     DCHECK_LE(1u, info->inflight_count);
     --info->inflight_count;
   }
-  if (info && info->is_done())
+  if (info && info->is_done()) {
     AllPreresolvesForUrlFinished(info);
+  }
   TryToLaunchPreresolveJobs();
 }
 
@@ -358,14 +387,16 @@ void PreconnectManager::AllPreresolvesForUrlFinished(PreresolveInfo* info) {
   auto it = preresolve_info_.find(info->url);
   CHECK(it != preresolve_info_.end(), base::NotFatalUntil::M130);
   DCHECK(info == it->second.get());
-  if (delegate_)
+  if (delegate_) {
     delegate_->PreconnectFinished(std::move(info->stats));
+  }
   preresolve_info_.erase(it);
 }
 
 network::mojom::NetworkContext* PreconnectManager::GetNetworkContext() const {
-  if (network_context_)
+  if (network_context_) {
     return network_context_;
+  }
 
   auto* network_context =
       browser_context_->GetDefaultStoragePartition()->GetNetworkContext();
diff --git a/chrome/browser/predictors/preconnect_manager.h b/chrome/browser/predictors/preconnect_manager.h
index d18470c05cdaffbc48b83cc0c76f7085442dccce..0c0a3f11a2da083ef5437a0e6abcf91afbcf9df3 100644
--- a/chrome/browser/predictors/preconnect_manager.h
+++ b/chrome/browser/predictors/preconnect_manager.h
@@ -17,7 +17,9 @@
 #include "base/time/time.h"
 #include "chrome/browser/predictors/proxy_lookup_client_impl.h"
 #include "chrome/browser/predictors/resolve_host_client_impl.h"
+#if 0
 #include "chrome/browser/predictors/resource_prefetch_predictor.h"
+#endif
 #include "net/base/network_anonymization_key.h"
 #include "url/gurl.h"
 
@@ -33,7 +35,28 @@ class NetworkContext;
 
 namespace predictors {
 
-struct PreconnectRequest;
+// Stores all values needed to trigger a preconnect/preresolve job to a single
+// origin.
+struct PreconnectRequest {
+  // |network_anonymization_key| specifies the key that network requests for the
+  // preconnected URL are expected to use. If a request is issued with a
+  // different key, it may not use the preconnected socket. It has no effect
+  // when |num_sockets| == 0.
+  PreconnectRequest(
+      const url::Origin& origin,
+      int num_sockets,
+      const net::NetworkAnonymizationKey& network_anonymization_key);
+  PreconnectRequest(const PreconnectRequest&) = default;
+  PreconnectRequest(PreconnectRequest&&) = default;
+  PreconnectRequest& operator=(const PreconnectRequest&) = default;
+  PreconnectRequest& operator=(PreconnectRequest&&) = default;
+
+  url::Origin origin;
+  // A zero-value means that we need to preresolve a host only.
+  int num_sockets = 0;
+  bool allow_credentials = true;
+  net::NetworkAnonymizationKey network_anonymization_key;
+};
 
 struct PreconnectedRequestStats {
   PreconnectedRequestStats(const url::Origin& origin, bool was_preconnected);
